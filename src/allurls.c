/*
Fake Identity Generator
Copyright (C) 2011-2016 Hibbard M. Engler (Bitcoin address 1ERDHsxtekdh5FAsxdb92PBFK7nnuwMkbp for gifts)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
/* 
NOTE -I tweaked this
1. Made it into not - so we get the middle management only.  I want to see if this helps things.


This code is a plug in module to rtr - our web server
RTR is a very efficient single threaded web server, and this code is probably better
off with a multithreaded deal, as it has several blocks due to memory mapping
100 gigabyte files in virtual memory.  In 10 years, this is trivial,  but not now.

So we limit the number of records shown to 20,  which gives about 1/2 second response time on the wan.
Unfortunately,  the web server is blocked during this,  but it should recover.
This code memory mapps n001.txt - which is our coveted file,
to see the format look at ../common/m.format.

This file has all the information pertaining to our fake identity,  with the original identity shrouded.
It is the basis for our product.

Originally,  I was going to sort the file with a header of various forms, and allow direct access to the file.
But this would make over 1 terabyte of redundant data,  and the sorting was kinds slow.


So now,  this uses index files.  fsort was modified to make these index files.  It is pretty awesome


Lets say we are sorting on state, then city,

fsort -q -d`cat random_seed` -n <n001.txt >example.txt 24 23

would make something like this:


0000000001|AL|Alturas|56725826|10356
0000000002|AL|Alturas|83478434|20393
^rownum    ^data      ^random  ^position

where
rownum is the row number added by the -q option of fsort.  This is prepended to the
output starting with 1,  with 10 decimal places to be sortable alpha an numerically at the same time.

data - the data that sort actually sorted, duh

random - a random number generated by -d option.  This shuffles the order of records presented
in order to hide the true order of n001.txt.  This is done so that we gan give fake id number
sets in the real world, as a form of watermarking.

position - a 64 bit number that is the numerical position of the n001.txt file that had the original
file.

So, this index file can be searched in two ways.  First,  the state and city can be searched
by skipping the first field.  Secondly,  the row number can allow us to jump ahead or behind
lograthmically.



So we have a bunch of these index files,  and we also have the big daddy - n001_everything.txt
n001_everything is designed to have every search term,  from all connotations.  It should
allow for effieient searching,  but only in the order that was specified.



This file emulates the directory tree. It is intended to look like a directory browser,  but ot does so much more

/<type>/[<offset>]/Term1/Term2


OK - to make these searches work, we need to make it real smooth
How I intend to do it:
type of search
then
/_020 - help with the underling
then
letters - 1 2 3, etc - use to identify whats what
then
we go as deep as we can.



*/


/* note - there are two versions - XDD for XDD.org and XDD2 for XDD2.org */
#ifndef XDD2
#define XDD
#endif



#define DEPTH_SEARCH

#define RANGE_SIZE 30

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include "util.h"
#include "bsearch.h"


struct searcher *main_file;

struct super_searcher *id_ss;
struct super_searcher *city_state;
struct super_searcher *first_last_middle;
struct super_searcher *first_middle_last;
struct super_searcher *last_first_middle;
struct super_searcher *phone_area_code;
struct super_searcher *ssn;
struct super_searcher *state_city;
//struct super_searcher *zip4_street;
//struct super_searcher *zip_name;
struct super_searcher *zip_street;


/*
base - main page
/lfm - last first middle - list the last names
/lfm/Engler - Engler main page
/lfm/Engler/_s1 - first set - list all 10
/lfm/Engler/Joe - all engler joes
/lfm/Engler/Joe//23123121
*/


char *convert_slash_to_ctrla(char *p1x,char *line)
{
      char *x,*y;
      x=line,y=p1x;
      while (*x) {
        if (*x == '/') {
          *y++ = 001; x++;
  	  }
        else {
          *y++ = *x++;
  	  }
        }
      *y = '\0';
return p1x;
}



void get_pos(char *buf,long long *pos) {
char *z = buf;
while (*buf) {
  if (*buf=='|') z=buf+1;
  buf++;
  }
*pos = atoll(z);
}


int dirfield(char *x, char *y,int fieldnum)
{
int flag=0;
char *z=y;
while (fieldnum && *x) {
  if ((*x == '/')) fieldnum--;
  x++;
  }
while (*x && (*x != '/')) {
  char ch=*x;
  if (ch!='/') {
    *z++ = ch;
    }
  x++;
  }
*z='\0';
if (*x == '/') flag=1;
return flag;
}





void dir_remainder_to_pipe(char *x, char *file,int fieldnum)
{
int flag=0;
char *z =file;
while (fieldnum && *x) {
  if ((*x == '/')) {
    fieldnum--;
    }
  x++;
  }
while (*x) {
  char ch=*x;
  if (ch=='/') {
    *z++ = '|';
    }
  else if (ch==001) { /* ctrl a special */
    *z++ = '/';
    }
  else {
    *z++ = ch;
    }
  x++;
  }
*z='\0';
}

void add_from_range_url( char *obuf,char *url,int from_range, int to_range) {
      char gbuf[2000];
      char *t;
      char *o=gbuf;
      t=url;
      if (*t) *o++= *t++;
      while ((*t)&&(*t) != '/') {
        *o++ = *t++;
         }
      if (*t=='/') t++;
      if (from_range) {
        while ((*t)&&(*t) != '/') {
           t++;
	   }
        if (*t=='/') t++;
	}
      *o = '\0';
      if (to_range) {
        sprintf(obuf,"%s/_%d/%s",gbuf,to_range,t);
	}
      else {
        sprintf(obuf,"%s/%s",gbuf,t);
	}

}



int check_pic (int ip)
{
  char fname[100];
  sprintf(fname,"i/%u.png",ip);
  struct stat sts;
  if (((stat(fname,&sts))== -1)/*||(rand() % 100 ==0)*/) {
    char biggerbuf[1000];
    sprintf(biggerbuf,"touch i/%u.png",ip);
    system(biggerbuf);
    sprintf(biggerbuf,"modify_pic.sh %u",ip);
    system(biggerbuf);
    }

}

void remove_range_url_trail( char *obuf,char *url,int from_range,char *trail) {
      char gbuf[2000];
      char *t;
      char *o=gbuf;
      t=url;
      if (*t) *o++= *t++;
      while ((*t)&&(*t) != '/') {
        *o++ = *t++;
         }
      if (*t=='/') t++;
      if (from_range) {
        while ((*t)&&(*t) != '/') {
           t++;
	   }
        if (*t=='/') t++;
	}
      *o = '\0';
      sprintf(obuf,"%s/%s",gbuf,t);
int l=strlen(obuf);
while ((l)&&obuf[l-1] != '/') {
  l--;
  }
if (obuf[l]) {
  strcpy(trail,obuf+l);
  obuf[l]='\0';
  }
else {
  trail[0]='\0';
  }
}



char *format_ccard(char *buf,char *in) {
int x=0;
while (*in) {
  if ((x)&&(x % 4)==0) {
    *buf++ = '-';
    }
  *buf++ = *in++;
  x=x+1;
  }
*buf='\0';
return buf;
}

char *format_ccard_tease(char *buf,char *in) {
int l=strlen(in);
int tease_count=l-5;
int x=0;
while (*in) {
  if ((x)&&(x % 4)==0) {
    *buf++ = '-';
    }
  *buf = *in++;
  if (x&&(tease_count>0)) { /* hide the second digit but show the last four to tease them */
    *buf='X';
    tease_count--;
    }
  buf++;
  x=x+1;
  }
*buf='\0';
return buf;
}



char *format_phone(char *buf,char *area,char *prefix, char *suffix) {
if ((area) && (*area)) {
  sprintf(buf,"(%s)%s-%s",area,prefix,suffix);
  }
else
  buf[0]='\0';
return buf;
}



char *html_header(char *buf,char *cookie_names[],char *cookie_values[]) {
sprintf(buf,"");
return buf;
}



char *html_start_section_body( char *buf,char *url,int ip,char *title) {
if (title == NULL) title="Index";
sprintf(buf,"");
}

char *html_end_section_body( char *buf) {
sprintf(buf,"");
}

char *html_footer(char *buf) {
*buf='\0';
return buf;
}



char * error_404(char *b,int *pbuflength) {
sprintf(b,"404\n");
*pbuflength = strlen(b);
return b;
}


char * warning_304(char *b,int *pbuflength) { /* not modified - a hack for evercookie detection */
sprintf(b,"304");
*pbuflength = strlen(b);
return b;
}


char *get_rec_at_line(char *line,char *id) {
int found;
char search_field[1000];
sprintf (search_field,"||||||||||%s|",id);
found=search(main_file,search_field,line);
return line;
}



/* follow_flag - returns a follow or a no follow on the links.  This is used to identify what pages
  google or other search engines should or should not crawl.  This makes only one copy
  of any destination link.
  Note that phn will work sometimes more from a regular link verus a spouse link
  that is because if we are browsing through phone numbers, only specific phone numbers
  get linked to on the spouses side.  But we can
  */
  
char *follow_flag(int id,char *method) {
/* 
ssn   20
phn1  30
phn2  10
flm   15
lfm   10
cs    15
*/
unsigned int idx;
char *rel;
idx = id;
idx = idx % 100;
rel=" rel=\"nofollow\"";  /* usual case */
#ifdef XDD
if (idx <20) {
  if (strcmp(method,"ssn")==0) rel=""; /* ssn */
  }
else {
  idx -= 20;
  if (idx < 30) {
    if ((strcmp(method,"phn1")==0)||(strcmp(method,"phn")==0)) rel=""; /* phone */
    }
  else {
    idx -= 30;
    if (idx < 10) {   /* phone 2 is cell phone,  less know to be real. */
      if ((strcmp(method,"phn2")==0)||(strcmp(method,"phn")==0)) rel=""; /* phone 2 */
      }
    else {
      idx -= 10;
      if (idx < 15) {   
        if (strcmp(method,"flm")==0) rel=""; /* flm */
	}
      else {
        idx -= 15;
	if (idx < 10) {
	  if (strcmp(method,"lfm")==0) rel=""; /* lfm */
	  }
	else {
	  idx -= 10;
	  /* if idx < 15 but we know it is */
	  if (strcmp(method,"cs")==0) rel=""; /* city state */
	  }
	}
      }
    }
  }
#else
/* for xdd2 it is always on for phone or ssn off otherwise */
if ((strcmp(method,"ssn")==0)||(strcmp(method,"phn1")==0)||(strcmp(method,"phn")==0)
    ||(strcmp(method,"phn2")==0)) {
  rel=""; /* ssn and phone are on.  The rest are nofollow */
  }
#endif
return rel;
}



char *follow_flag_consider_phone (int id,char *mode,
  char *ac1,char *prefix1, char *suffix1,
  char *ac2,char *prefix2, char *suffix2,
  char *url_part)
{
if ((strcmp(mode,"phn")==0)&&(suffix1[0])&&(suffix2[0])) {
  char b1[2000];
  char b2[2000];
  char test[2000];
  /* url part is something like  56/(440)315-1156/0 , hacky but true
     We clip off the start and end and make it (440)315-1156
     then we can compare apples and oranges and make sure we link to phn1 or phn2 accordingly
     That way every person will only be listed once */
  strcpy(test,url_part+3); /* skip dd/ */
  test[13]='\0'; /* clip off the /0 */
  sprintf(b1,"(%s)%s-%s",ac1,prefix1,suffix1);
  sprintf(b2,"(%s)%s-%s",ac2,prefix2,suffix2);
  if (strcmp(test,b1)==0) {
    mode="phn1";
    }
  else if (strcmp(test,b2)==0) {
    mode="phn2";
    }
  else {
    fprintf(stderr,"ERROR %s %s %s\n",test,b1,b2);
    }
  }
return follow_flag(id,mode);
}

char *get_link_via_id(char *buf,char *id,char **pfollow,int link_sequence) 
{
char line[20000];
get_rec_at_line(line,id);

char *f[1000];
int cols=0;
if (line[0]) {
      char *q=line;
      char *r1=q;
      while (*r1) {
        while (*r1 &&(*r1 != '|')) r1++;
        f[cols++] =q;
        if (*r1) {
          *r1 = '\0';
          r1++;
          }
        q=r1;
        }
  } /* if we found a line */
else { /* cant find it - default to the id as a last resort */
  sprintf(buf,"/id/%s/",id);
  *pfollow = " rel = \"nofollow\"";
  return buf;
  }
int save_rand;
save_rand = rand();   /* we set the random number to the id so that the links are consistent */
int iid;
iid=atoi(id);
srand(iid + link_sequence*7);
if ((rand()%3) ==2)  { /*if we are going to do ssn */
  sprintf(buf,"/ssn/%s/%s/%s/%s/",f[46],f[47],f[48],f[49]);
  srand(save_rand);
  *pfollow = follow_flag(iid,"ssn");
  return buf;
  }
else { /* phone number */
  if ( ((f[41][0]) &&(f[27][0])&& ((rand()%2) ==1))||
     ((f[41][0]) && (f[27][0]=='\0'))
     )
    {
    if ((f[41][0])&&(f[27][0]))
      *pfollow = follow_flag(iid,"phn1");
    else
      *pfollow = follow_flag(iid,"phn");
    sprintf(buf,"/phn/%s/%s/%s/(%s)%s-%s/0",f[39],f[40],f[41],f[39],f[40],f[41]);
    }
  else if (f[27][0]) {
    if ((f[41][0])&&(f[27][0])) 
      *pfollow = follow_flag(iid,"phn2");
    else 
      *pfollow = follow_flag(iid,"phn");
    sprintf(buf,"/phn/%s/%s/%s/(%s)%s-%s/0",f[25],f[26],f[27],f[25],f[26],f[27]);
    }
  else {
    *pfollow = follow_flag(iid,"ssn");
    sprintf(buf,"/ssn/%s/%s/%s/%s/",f[46],f[47],f[48],f[49]);
    }
  srand(save_rand);
  return buf;
  }
}

void get_link_via_ids(char *id,char *spouse_link1,char *spouse_link2,char *spouse_link3,
   char *spouse_link4,
   char **pfollow1,char **pfollow2,char **pfollow3,char **pfollow4) {
get_link_via_id(spouse_link1,id,pfollow1,0);
get_link_via_id(spouse_link2,id,pfollow2,1);
get_link_via_id(spouse_link3,id,pfollow3,2);
get_link_via_id(spouse_link4,id,pfollow4,3);
}


void find_line_xcount(char *r,int fieldnum,char *line,char *xcount,struct searcher *base_searcher,
  struct sup_searcher *sup_searcher) {
char *x;
char *lx = line;
char *cx = xcount;
char *prev_left_off=NULL;
int f=0;
/* skip the first matched fields */
for (x=r;(*x)&&(f<fieldnum);x++)  { if (*x=='|') f++; }

/* print out the text and the count */
for (;*x;x++)  {
  if (*x=='|') {
    *lx++='/';
    prev_left_off=lx;
    *cx = '\0';
    cx = xcount;
    }
  else if (*x=='/') {
    *(cx++) = 001;
    *lx++ =001; /* ctrla */
    }
  else {
    *(cx++) = *x;
    *(lx++) = *x;
    }
  }
*cx = '\0';
*lx = '\0';
if (prev_left_off) { /* do we add or not add the last /?  This is problematic. hmmmm
                            I guess that if we are displaying a non base subset, we leave it off
			    but if we are a base subset, we leave it on
			    There was a bug here - where we were comparing
			   prev_left_off to r - we should have been comparing to line
                            */
  if ((sup_searcher)&&(sup_searcher->base != base_searcher)&&(prev_left_off != line)) {
    prev_left_off--; /* remove / */
    }
  *prev_left_off='\0';
  /*if completely empty, forget it */
  if (line[0]=='\0') {
    strcat(line,"/");
    }
  }
}





int display_page(int level,struct super_searcher *super_search,
    int searching, /* non zero if we are searching at a strange offset */
    char *url,
    int offset,char *mode)
{
char f1[2000];
char f2[2000];
char f3[2000];
char search_field[2000];
char results[2000];
char xoffset[2000];
char *hack;
int original_offset;

unsigned long long nextline;
int found;
int from_range;
int weirdness; /* weirdness goes up if the url or something is a bit off */


int details_done;
details_done = 0;

original_offset=offset;

iterate:
hack = NULL;
from_range=0;
weirdness=0; /* weirdness goes up if the url or something is a bit off */

if (searching) {
  dirfield(url,xoffset,offset+0);
  if (xoffset[0]=='_') {  /* range folder - ignore */
    from_range = atoi(xoffset+1);
    int original_from_range = from_range;

    /* clean up from_range for hackers */
    if (from_range<0) from_range = -(from_range);
    from_range = ((from_range+(RANGE_SIZE-1))/RANGE_SIZE)*RANGE_SIZE;
    if (!from_range) from_range +=RANGE_SIZE;
    if (from_range != original_from_range) {
      hack="Weird from range";
      }

    offset++;
    }
  }

dir_remainder_to_pipe(url,f1,offset+0); /* convert from abc/_RANGE_SIZE/sue/markus/y to sue|markus|y */

char base_url_clean[2000];
char trail[2000];

remove_range_url_trail(base_url_clean,url,from_range,trail);


sprintf(search_field,"%s",f1);
int supindex;
int searchindex;
int fieldnum;
int letter_count;
struct searcher *base_searcher;
struct sup_searcher *sup_searcher;
found =super_search_first_range_over(super_search,search_field,results,&nextline,1,
  &supindex,&searchindex,&base_searcher,&sup_searcher,&fieldnum,&letter_count);
int l=strlen(search_field);



if (from_range) {
  int r = atoi(results);
  r = r + from_range;
  char uu[100];
  sprintf(uu,"%010d|",r);
  found =search_first_range_over(base_searcher,uu,results,&nextline,0);
  }



int show_base_flag=0;
if (base_searcher == super_search->base) show_base_flag=1;

if (!show_base_flag) { /* we are above the base - show that */
  int count=0;
  int first_record=1;



  {
    /* skip one field in result */
    char *r=results;
    while ((*r)&&(*r!= '|')) r++;
    if (*r=='|') r++;

    found = !(strncmp(search_field,r,l)); /* filter it to make sure we match */
    }


  while (1) {
    long long curpos;


    /* skip one field in result */
    char *r=results;
    while ((*r)&&(*r!= '|')) r++;
    if (*r=='|') r++;



    found = !(strncmp(search_field,r,l)); /* filter it to make sure we match */
    if (!found) { /* cannot find a match  OK */
      if (first_record) { /* something is wrong, we should get at least one match */
        if (from_range) {  /* the from range should never be too high, unless they FABRICATED the URL */
	  hack="Dir From range too high";
	  }
	else {
	  hack="Dir Invalid Search"; /* Invalid search might be possible. But PROBABLY NOT!!!! */
	  }
        }
      break;
      }

    if (count>=RANGE_SIZE) break; /* went too far */

    if (first_record) {
      first_record=0;



      if (from_range) {/* have more to do - make a previous set section */
        char obuf[2000];
        char ubuf[2000];
        char gbuf[2000];

        add_from_range_url(obuf,url,from_range,from_range-RANGE_SIZE);
        } /* if we have more to do */


      } /* if this is the first time we got a record */


    char gbuf[2000];
    char line[2000];
    char xcount[2000];

    find_line_xcount(r,fieldnum,line,xcount,base_searcher,sup_searcher);


    char p1[2000];
    char p2[2000];
    char p3[2000];
    sprintf(p3,"%s%s",base_url_clean,line);
    if (strcmp(url,p3)==0) {
      sprintf(p3,"%s%s",encode_url(p1,base_url_clean,512),encode_url(p2,line,512));
      strcpy(p1,line);
      strcat(p3,"/");
      strcat(p1,"/");
      }
    else {
      sprintf(p3,"%s%s",encode_url(p1,base_url_clean,512),encode_url(p2,line,512));
      strcpy(p1,line);
      }

    sprintf(gbuf,"");
    make_external_call(p3,level+1);
    details_done++;
    found=search_next_range(base_searcher,search_field,results,&nextline);

    count++;
    if (!found) { /* quit early - we will trust this found */
      break;
      }
    } /* while displaying all the records */

  if (found) {/* have more to do */
    char obuf[2000];
    char gbuf[2000];
    char ubuf[2000];
    add_from_range_url(obuf,url,from_range,from_range+RANGE_SIZE);
    from_range = from_range+from_range+RANGE_SIZE;
    strcpy(url,obuf);
    level=level+1;
    searching=1;
    offset = original_offset;
    fprintf(stdout,"%s\n",url); /* lets assume that we are good */
    goto iterate;
//    make_external_call(encode_url(ubuf,obuf,512),level+1);

    } /* if we have more to do */

  } /* index */
else { /* show the details */
  char *rest;
  char *r=results;
  while ((*r)&&(*r!= '|')) r++;
  if (*r=='|') r++;
  found = !(strncmp(search_field,r,l)); /* filter it to make sure we match */
  if (found) {
    rest = r+l;
    if (*rest=='|') rest++; /* skip the first vertical bar here */
    char *done_check;
    done_check=rest;
    /* see if we have a | in the file */
    if (index(rest,'|')) {
      /* here we are printing out a table of records that match the search criteria */
//      html_start_section_body(e,url,ip,dbuf);

/*??? indent 4 vvv */
  int first_record=1;
  int count=0;
  while (1) {
    long long curpos;

    /* skip one field in result */
    char *r=results;
    while ((*r)&&(*r!= '|')) r++;
    if (*r=='|') r++;

    found = !(strncmp(search_field,r,l)); /* filter it to make sure we match */

    if (!found) { /* something is wrong here */
      if (first_record) { /* something is wrong, we should get at least one match */
        if (from_range) {  /* the from range should never be too high, unless they FABRICATED the URL */
	  hack="File From range too high";
	  }
	else {
	  hack="File Invalid Search"; /* Invalid search might be possible. But PROBABLY NOT!!!! */
	  }
        }
      break;
      }

    if (count>=RANGE_SIZE) break;

    if (first_record) {
      first_record=0;
      if (from_range) {/* have more to do */
        char obuf[2000];
        char gbuf[2000];
	char ubuf[2000];
        add_from_range_url(obuf,url,from_range,from_range-RANGE_SIZE);
//	make_external_call(encode_url(ubuf,obuf,512),level+1  - previous set
        } /* if we have a previous set */

      /* OK print out the table header */
      char gbuf[2000];

      } /* if this is the first time we got a record */

    char line[2000];
    char xcount[2000];

    find_line_xcount(r,fieldnum,line,xcount,base_searcher,sup_searcher);


    char p1[2000];
    char p2[2000];

#ifdef XDD    

    /* get the exacting value */
    char rest[2000];
    strcpy(rest,r+l);
    /* pull a line from the main file, thanks to the cursor position */
    get_pos(results,&curpos);

    char ch;
    char *x = main_file->map + curpos;
    char *xb=x;
    while ((*x)&&(*x != '\n')) x++;

    /* split into an array of fields */
    char abuf[20000];
    strncpy(abuf,xb,x-xb);
    abuf[x-xb]='\0';
    char *f[1000];
    int cols=0;
    char *q=abuf;
    char *r1=q;
    while (*r1) {
      while (*r1 &&(*r1 != '|')) r1++;
      f[cols++] =q;
      if (*r1) {
        *r1 = '\0';
        r1++;
        }
      q=r1;
      }
      
    char rest2[2000];
    char rest2_html[2000];
    char trail_html[2000];
    {
      char *x = rest;
      char *z = rest2;
      char *lastspot;
      lastspot=z;
      while (*x) {
        if ((*x) == '|') {
          *z = '/';
	  lastspot=z;
	  }
        else if ((*x) == '/') {
          *z = 001;
	  lastspot=z;
	  }
        else *z = *x;
        x++;
        z++;
        } /* while converting | to / */
      *lastspot = '\0'; /* clip of the very last field - that should be the position field */
      } /* block to make rest2 from dfhjdfs|dfsdfsdf|34672 to  dfhjdfs/dfsdfsdf */

    char gbuf[2000]	;
    char buf31[2000];
    char rest2_url[2000];
    char trail_url[2000];
    sprintf(gbuf,"%s%s%s",
         encode_url(buf31,base_url_clean,9999),
	 encode_url(trail_url,trail,9999),
	 encode_url(rest2_url,rest2,9999)
	  );
    int id=atoi(f[10]);
    char *follow=follow_flag_consider_phone(id,mode,f[39],f[40],f[41],f[25],f[26],f[27],rest2);
    if (strcmp(follow,"")==0) {
      make_external_call(gbuf,level+1);
      }
#endif      
    details_done++;
    found=search_next_range_over(base_searcher,search_field,results,&nextline,1);
    count++;
    if (!found) {
      break;
      }

    }


  if (found) {/* have more to do */
    char obuf[2000];
    char gbuf[2000];
    char ubuf[2000];
    add_from_range_url(obuf,url,from_range,from_range+RANGE_SIZE);
    from_range = from_range+from_range+RANGE_SIZE;
    strcpy(url,obuf);
    level=level+1;
    searching=1;
    offset = original_offset;
    fprintf(stdout,"%s\n",url); /* lets assume that we are good */
    goto iterate;
//    make_external_call(encode_url(ubuf,obuf,512),level+1);
    } /* if we have more to do */


      } /* if we are not exact - and doing the table mode */
    else { /* exactly one record this one */
      int x=1;
      x=x+1;
      } /* if we are an exact match */
    } /* if found */
  else { /* not found something weird */
    return 0;
    }
  if (details_done != 1) {
    return 1;
    }
  } /* if table or single entry */
return 0;
}



int init (int argc, char *argv[]) {
int i;
for (i=1;i<argc;i++) {
    srandom(atoi(argv[i]));
  }


/*??? add DL? */
#ifdef XDD
main_file = new_searcher("../out/n001.txt",11,0,0);
id_ss = new_super_searcher("../out/n001_id.txt",1,0,0);
city_state = new_super_searcher("../out/n001_city_state.txt",6,0,0);
first_last_middle = new_super_searcher("../out/n001_first_last_middle.txt",5,0,0);
first_middle_last = new_super_searcher("../out/n001_first_middle_last.txt",4,0,0);
last_first_middle = new_super_searcher("../out/n001_last_first_middle.txt",5,0,0);
phone_area_code = new_super_searcher("../out/n001_phone_area_code.txt",5,0,0);
ssn = new_super_searcher("../out/n001_ssn.txt",4,0,0);
state_city = new_super_searcher("../out/n001_state_city.txt",12,0,0);
//zip4_street = new_super_searcher("../out/n001_zip4_street.txt",10,0,0);
//zip_name = new_super_searcher("../out/n001_zip_name.txt",7,0,0);
zip_street = new_super_searcher("../out/n001_zip_street.txt",10,0,0);
#else
phone_area_code = new_super_searcher("../out/n001_phone_area_code.txt",5,0,0);
ssn = new_super_searcher("../out/n001_ssn.txt",4,0,0);
#endif
return 0;
}









void welcome_page(int level) {
make_external_call("/cs",level+1);
make_external_call("/flm",level+1);
make_external_call("/fml",level+1);
make_external_call("/lfm",level+1);
make_external_call("/phn",level+1);
make_external_call("/sc",level+1);
make_external_call("/ssn",level+1);
make_external_call("/zip",level+1);
//make_external_call("/id",level+1);
}







make_external_call(char *url,int level) {
#ifndef DEPTH_SEARCH
if (level>1) return;
#endif
{
  //printf("--%s\n",url);
    char *z;
    for (z=url;*z;z++) {
      if (*z <' ') *z = ' ';
      }
  }

char f1[2000];
int offset=2;
char *origurl;
char buff[513];
decode_url(buff,url,512);
origurl=url;
url=buff;
int searching=dirfield(url,f1,1);
int flag=0;

if (strcmp(f1,"cs")==0) {
  flag=(display_page(level,city_state,searching,url,offset,f1));
  }
if (strcmp(f1,"phn")==0) {
  flag=(display_page(level,phone_area_code,searching,url,offset,f1));
  }
if (strcmp(f1,"fml")==0) {
  flag=(display_page(level,first_middle_last,searching,url,offset,f1));
  }
if (strcmp(f1,"flm")==0) {
  flag=(display_page(level,first_last_middle,searching,url,offset,f1));
  }
if (strcmp(f1,"lfm")==0) {
  flag=(display_page(level,last_first_middle,searching,url,offset,f1));
  }
if (strcmp(f1,"ssn")==0) {
  flag=(display_page(level,ssn,searching,url,offset,f1));
  }
if (strcmp(f1,"sc")==0) {
  flag=(display_page(level,state_city,searching,url,offset,f1));
  }
if (strcmp(f1,"zip")==0) {
  flag=(display_page(level,zip_street,searching,url,offset,f1));
  }
//if (strcmp(f1,"zlfm")==0) {
//  flag=(display_page(level,zip_name,searching,url,offset,f1));
//  }
if (strcmp(f1,"id")==0) {
  flag=(display_page(level,id_ss,searching,url,offset,f1));
  }
if (strcmp(f1,"")==0) {
  welcome_page(level);
  }
#ifndef DEPTH_SEARCH
if (level>=1) {
  printf("%s\n",url);
  if (flag) {
    fprintf(stderr,"%s\n",origurl);
    }
  }
#else
  if (flag) {
    printf("%s\n",origurl);
    }
#endif
}



int main() {
 (init(0,NULL));
char buf[20000];
int level;
while (gets(buf)) {
  level=0;
  make_external_call(buf,level);
  }
}
